<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Seedwave™ - Global Pulse & Master Brands</title>
    <link rel="icon" href="/favicon.ico">
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter for clean typography -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <!-- Chart.js for the new pulse graph -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.js"></script>
    <style>
        /* Base Styles - More dynamic and modern for Seedwave */
        :root {
            /* Keep original dark theme colors for hero grid elements only */
            --dark-bg: #0a0a0d; /* Very dark almost black */
            --primary-glow: #00e393; /* Greenish glow, Tesla-inspired */
            --secondary-glow: #007bff; /* Blue glow, Google/Apple-inspired */
            --accent-red: #ff4d4d;
            --card-bg-dark: #1c1c21;
            --border-dark: #3a3a42;
            --font-inter: 'Inter', sans-serif;

            /* Fruitful Branding Colors - now unified and white for header */
            --fruitful-logo-color: #ffffff; /* Unified white for Fruitful™ | Seedwave™ */
            --fruitful-separator-color: #bbbbbb; /* Lighter grey for separator */

            /* NEW: General page background and text colors (Black & White) */
            --page-bg-light: #ffffff; /* Pure white background */
            --page-text-dark: #000000; /* Pure black text */
            --page-muted-text: #333333; /* Dark grey muted text */
            --page-border-light: #cccccc; /* Light grey border */

            /* NEW: Accent colors for metrics/charts in B&W theme (subtle grey tones) */
            --accent-blue-light: #555555; /* Medium grey for icons/values */
            --accent-green-light: #777777; /* Slightly lighter grey */
            /* IMPORTANT: The canvas animations and Chart.js lines will retain their vibrant colors explicitly in JS */
        }

        body {
            font-family: var(--font-inter);
            background-color: var(--page-bg-light); /* Apply new light background */
            color: var(--page-text-dark); /* Apply new dark text color */
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow-x: hidden; /* Prevent horizontal scrolling */
        }

        /* Header - Background remains dark, logos are white */
        header {
            background-color: #0a0a0d; /* Solid dark background for header */
            backdrop-filter: none; /* No blur, solid dark */
            border-bottom: 1px solid var(--border-dark);
            padding: 1rem 2rem;
            position: sticky;
            top: 0;
            z-index: 50;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .header-content-wrapper {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        .logo-group {
            display: flex;
            align-items: center;
            gap: 10px;
            /* Colors defined directly on logo elements now */
            flex-shrink: 0; /* Prevent shrinking */
        }

        /* Unified Fruitful™ | Seedwave™ Logo (white and steady) */
        .logo-fruitful, .logo-seedwave {
            color: var(--fruitful-logo-color); /* White */
            font-size: 1.6rem;
            font-weight: 800;
            text-decoration: none;
            text-shadow: none; /* No glow/pulse */
            transition: none; /* No transitions */
        }
        .logo-separator {
            color: var(--fruitful-separator-color); /* Lighter grey for separator */
            font-size: 1.4rem;
            font-weight: 600;
            text-shadow: none; /* No glow/pulse */
        }

        /* New: Stock Exchange Pulse Canvas in Header */
        #header-pulse-canvas {
            flex-grow: 1; /* Take up available space */
            height: 40px; /* Fixed height for the pulse */
            background-color: transparent;
            margin: 0 20px; /* Space between logo and right edge */
            max-width: 600px; /* Limit width to keep it narrow */
            min-width: 100px; /* Ensure it has some width even on smaller desktops */
        }

        /* Hero Section - Still dark and funky, as requested */
        .hero-section {
            position: relative;
            height: 90vh; /* Taller hero section */
            display: flex;
            flex-direction: column; /* Stack button and grid */
            align-items: center;
            justify-content: center;
            text-align: center;
            overflow: hidden;
            /* Background radial gradient based on original glow colors */
            background: radial-gradient(circle at center, rgba(0, 227, 147, 0.05) 0%, transparent 60%);
            padding: 2rem; /* Add padding for breathing room */
            background-color: var(--dark-bg); /* Ensure dark background */
        }

        .hero-pulse-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr); /* 3 columns */
            grid-template-rows: repeat(2, 1fr); /* 2 rows */
            gap: 1rem; /* Space between canvas blocks */
            width: 100%;
            height: 100%; /* Fill hero section */
            max-width: 1200px; /* Limit overall grid size */
            max-height: 80vh; /* Adjust max height to leave space for button */
            margin-top: 2rem; /* Space below the button */
        }

        .pulse-container {
            position: relative;
            background-color: var(--card-bg-dark); /* Dark background for each pulse block */
            border-radius: 0.75rem; /* Rounded corners */
            overflow: hidden;
            border: 1px solid var(--border-dark);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .pulse-container canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
            background-color: transparent; /* Ensure canvas background is transparent */
            z-index: 1;
        }

        .hero-cta-button {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 1rem 2.5rem;
            background: linear-gradient(45deg, #007bff, #0056b3); /* Blue gradient */
            color: white;
            text-decoration: none;
            border-radius: 9999px; /* Fully rounded */
            font-weight: 700;
            font-size: 1.1rem;
            box-shadow: 0 5px 20px rgba(0, 123, 255, 0.4);
            transition: all 0.3s ease-in-out;
            opacity: 1; /* Always visible now */
            animation: none; /* Remove initial animations as text is gone */
            border: 1px solid rgba(0, 123, 255, 0.5);
            margin-bottom: 2rem; /* Space between button and grid */
            position: relative; /* Ensure it's above the grid but below header */
            z-index: 20; /* Higher than grid but lower than header */
        }
        .hero-cta-button:hover {
            background: linear-gradient(45deg, #0056b3, #007bff); /* Inverted gradient */
            box-shadow: 0 8px 25px rgba(0, 123, 255, 0.6);
            transform: translateY(-5px) scale(1.02);
            border-color: rgba(0, 123, 255, 0.8);
        }

        /* General Section Styling (for content below hero) */
        section {
            padding: 6rem 2rem;
            background-color: var(--page-bg-light); /* Now uses light background */
            border-top: 1px solid var(--page-border-light); /* Light border */
            text-align: center;
            color: var(--page-text-dark); /* Dark text for general sections */
        }

        h2 {
            font-size: 3rem;
            font-weight: 800;
            color: var(--page-text-dark); /* Dark text */
            margin-bottom: 3rem;
            text-shadow: none; /* No text shadow for clean look */
        }

        /* Metrics / Operational Blocks */
        .operational-blocks-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 2.5rem;
            max-width: 1200px;
            margin: 0 auto;
        }

        .operational-block {
            background-color: #ffffff; /* Pure white block background */
            border-radius: 1rem;
            padding: 2.5rem; /* Slightly more padding */
            box-shadow: 0 4px 15px rgba(0,0,0,0.08); /* Softer shadow */
            border: 1px solid var(--page-border-light); /* Light border */
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            position: relative;
            overflow: hidden;
            color: var(--page-text-dark); /* Ensure dark text within cards */
            display: flex; /* Flexbox for centering content */
            align-items: center;
            justify-content: center;
        }
        .operational-block:hover {
            transform: translateY(-5px) scale(1.01); /* Softer hover effect */
            box-shadow: 0 6px 20px rgba(0,0,0,0.12);
        }
        .operational-block h3 {
            font-size: 2rem; /* Larger font for impact */
            font-weight: 900; /* Extra bold */
            color: var(--page-text-dark); /* Pure black */
            line-height: 1.2;
            margin: 0; /* Remove default margin */
            padding: 0; /* Remove default padding */
        }


        /* Master License Brands Section */
        #master-brands {
            background-color: var(--page-bg-light); /* Consistent light background */
            color: var(--page-text-dark);
        }
        #master-brands h2 {
            color: var(--page-text-dark);
            text-shadow: none;
        }
        #master-brands .art-typo-container {
            text-align: left; /* Align the art typo content to the left */
            font-family: monospace; /* Monospace font for precise alignment */
            line-height: 1; /* Tight line spacing */
            font-size: 1.1rem; /* Adjust font size for art typo */
            color: var(--page-muted-text); /* Muted text for the art typo */
            max-width: 700px; /* Limit width */
            margin: 0 auto 3rem auto; /* Center the block and add bottom margin */
            white-space: pre-wrap; /* Preserve whitespace and wrap lines */
        }


        /* New styling for the brand blocks */
        .master-brand-blocks-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 2.5rem; /* Consistent gap */
            max-width: 1200px; /* Max width for the grid */
            margin: 0 auto; /* Center the grid */
        }

        .master-brand-block {
            background-color: #ffffff; /* Pure white block background */
            border-radius: 1rem;
            padding: 2.5rem;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
            border: 1px solid var(--page-border-light);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            text-decoration: none; /* Remove underline for links */
            color: var(--page-text-dark); /* Ensure text is black */
        }
        .master-brand-block:hover {
            transform: translateY(-5px) scale(1.01);
            box-shadow: 0 6px 20px rgba(0,0,0,0.12);
        }
        .master-brand-block h3 {
            font-size: 2rem; /* Consistent large bold text */
            font-weight: 900;
            color: var(--page-text-dark); /* Pure black */
            line-height: 1.2;
            margin: 0;
            padding: 0;
        }


        /* Node.js Infiltration Pulse Graph Section (Updated for light theme) */
        #node-pulse-graph {
            background-color: var(--page-bg-light); /* Consistent light background */
            color: var(--page-text-dark);
        }
        #node-pulse-graph h2 {
            color: var(--page-text-dark);
            text-shadow: none;
        }
        #node-pulse-graph .bg-gray-900 { /* Chart container background */
            background-color: #ffffff; /* White background for chart */
            border-color: var(--page-border-light); /* Light border */
            box-shadow: 0 4px 15px rgba(0,0,0,0.08); /* Softer shadow */
        }
        #node-pulse-graph canvas {
            background-color: transparent; /* No background fill, handled by container */
        }
        #node-pulse-graph p {
            color: var(--page-muted-text);
        }


        /* Footer (Updated for light theme) */
        footer {
            background-color: #f5f5f7; /* Very light grey footer */
            border-top: 1px solid var(--page-border-light);
            padding: 2.5rem;
            text-align: center;
            color: var(--page-muted-text); /* Muted dark text */
            font-size: 0.9rem;
        }
        footer a {
            color: var(--page-muted-text); /* Muted link color */
            text-decoration: none;
            transition: color 0.3s ease;
        }
        footer a:hover {
            color: var(--accent-blue-light); /* Hover to accent color (now grey) */
        }

        /* Animations (remain, but apply to relevant elements only) */
        @keyframes fadeInScale {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes fadeInSlideUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Responsive Adjustments */
        @media (max-width: 1024px) { /* Adjust grid for tablets */
            .hero-pulse-grid {
                grid-template-columns: repeat(2, 1fr); /* 2 columns on tablet */
                grid-template-rows: repeat(3, 1fr); /* 3 rows on tablet */
            }
        }
        @media (max-width: 768px) {
            header { padding: 1rem; }
            .logo-group .logo-fruitful, .logo-group .logo-seedwave { font-size: 1.4rem; }
            .logo-separator { font-size: 1.2rem; }

            #header-pulse-canvas {
                display: none; /* Hide header pulse on mobile to save space */
            }

            .hero-pulse-grid {
                grid-template-columns: 1fr; /* Single column on mobile */
                grid-template-rows: repeat(6, 1fr); /* 6 rows on mobile */
                max-height: none; /* Allow grid to stretch */
            }
            .hero-cta-button { padding: 0.8rem 2rem; font-size: 1rem; }
            h2 { font-size: 2.2rem; }
            section { padding: 4rem 1rem; }
            .operational-blocks-grid, .master-brand-blocks-grid { grid-template-columns: 1fr; } /* Stack on mobile */
            .operational-block h3, .master-brand-block h3 { font-size: 1.5rem; }
            .art-typo-container { font-size: 0.9rem; } /* Adjust font size for art typo on mobile */
            footer { padding: 1.5rem; }
        }
    </style>
</head>
<body>

    <header>
        <div class="header-content-wrapper">
            <div class="logo-group">
                <a href="#" class="logo-fruitful">Fruitful™</a>
                <span class="logo-separator">|</span>
                <span class="logo-seedwave">Seedwave™</span>
            </div>
            <!-- New: Stock Exchange Pulse Canvas in Header -->
            <canvas id="header-pulse-canvas"></canvas>
            <!-- Right nav bar removed -->
        </div>
    </header>

    <main>
        <section class="hero-section" id="pulse">
            <!-- Text content removed -->
            <a href="homepage.html" class="hero-cta-button">
                Discover the Future <i class="fas fa-arrow-right"></i>
            </a>
            <div class="hero-pulse-grid">
                <div class="pulse-container">
                    <canvas id="canvas-rhythmic"></canvas>
                </div>
                <div class="pulse-container">
                    <canvas id="canvas-concentric"></canvas>
                </div>
                <div class="pulse-container">
                    <canvas id="canvas-shooting"></canvas>
                </div>
                <div class="pulse-container">
                    <canvas id="canvas-particles"></canvas>
                </div>
                <div class="pulse-container">
                    <canvas id="canvas-radial-bursts"></canvas>
                </div>
                <div class="pulse-container">
                    <canvas id="canvas-hyperspace"></canvas>
                </div>
            </div>
        </section>

        <!-- Replaced "Our Interstellar Impact" section with new blocks -->
        <section id="operational-pillars">
            <!-- Removed h2 heading as requested -->
            <div class="operational-blocks-grid">
                <div class="operational-block">
                    <h3>Auto Design</h3>
                </div>
                <div class="operational-block">
                    <h3>Auto Build</h3>
                </div>
                <div class="operational-block">
                    <h3>Auto Deploy</h3>
                </div>
            </div>
        </section>

        <!-- New: Master License Brands Section - Adjusted for B&W -->
        <section id="master-brands" class="py-16 px-6 text-center">
            <h2 class="text-4xl font-bold mb-8">Seedwave™ Global Master License Brands</h2>
            <div class="art-typo-container">
<pre>
Seedwave™:
    The Nexus.
      A Portfolio of Innovation.
        Digital Enterprises and Beyond.
          Groundbreaking Non-Digital Ventures.
            Cultivating Tomorrow.
              Rapid Deployments.
                Global Repositories.
                  Tangible Presence.
                    The Pulse of Expansion.
                      Across All Frontiers.
                        Every Brand, A Node.
                          Driving Collective Impact.
</pre>
            </div>
            <!-- New: Master Brand Blocks -->
            <div class="mt-12 operational-blocks-grid master-brand-blocks-grid">
                <a href="https://samfox.faa.zone" target="_blank" class="master-brand-block">
                    <h3>Samfox™</h3>
                </a>
                <a href="https://seedwave.faa.zone" target="_blank" class="master-brand-block">
                    <h3>Seedwave™</h3>
                </a>
                <a href="https://faa.zone/" target="_blank" class="master-brand-block">
                    <h3>FAA.ZONE™</h3>
                </a>
            </div>
        </section>


        <!-- Node.js Infiltration Pulse Graph Section -->
        <section id="node-pulse-graph" class="py-16 px-6 text-center">
            <h2 class="text-4xl font-bold mb-8">Node.js Infiltration Pulse</h2>
            <div class="w-full max-w-5xl mx-auto bg-gray-900 p-6 rounded-xl shadow-lg border border-gray-700">
                <canvas id="nodePulseChart"></canvas>
            </div>
            <p class="text-sm text-page-muted-text mt-4 max-w-2xl mx-auto">
                Real-time visualization of Node.js package infiltration, repo deployments, and array count growth across sectors.
            </p>
        </section>

    </main>

    <footer>
        <p>&copy; 2025 Seedwave™. All rights reserved.</p>
        <p>A proud partner of <a href="https://faa.zone/" target="_blank">FAA.zone™ Treaty System™</a></p>
    </footer>

    <script>
        // Store canvas elements and their contexts
        const canvases = {
            rhythmic: { canvas: document.getElementById('canvas-rhythmic'), ctx: null, time: 0, animationId: null },
            concentric: { canvas: document.getElementById('canvas-concentric'), ctx: null, time: 0, animationId: null },
            shooting: { canvas: document.getElementById('canvas-shooting'), ctx: null, time: 0, animationId: null, pulses: [] },
            particles: { canvas: document.getElementById('canvas-particles'), ctx: null, time: 0, animationId: null, particles: [] },
            radialBursts: { canvas: document.getElementById('canvas-radial-bursts'), ctx: null, time: 0, animationId: null, bursts: [] },
            hyperspace: { canvas: document.getElementById('canvas-hyperspace'), ctx: null, time: 0, animationId: null }
        };

        // New: Header Pulse Canvas object
        const headerPulse = {
            canvas: document.getElementById('header-pulse-canvas'),
            ctx: null,
            time: 0,
            animationId: null,
            data: [], // Stores data points for the graph
            maxDataPoints: 50, // Number of points visible
            valueRange: 100, // Max value for fluctuations
            speed: 0.8 // Speed of the graph scroll
        };


        // Initialize contexts and start animation loops for each canvas
        function initCanvases() {
            // Initialize header pulse canvas first
            if (headerPulse.canvas) {
                headerPulse.ctx = headerPulse.canvas.getContext('2d');
                resizeHeaderPulseCanvas();
                startHeaderPulseAnimation();
            }

            for (const key in canvases) {
                if (canvases[key].canvas) {
                    canvases[key].ctx = canvases[key].canvas.getContext('2d');
                    resizeCanvas(canvases[key].canvas); // Initial resize
                    startAnimation(key);
                }
            }
        }

        // Resize individual canvas elements
        function resizeCanvas(canvas) {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }

        // Resize header pulse canvas
        function resizeHeaderPulseCanvas() {
            if (headerPulse.canvas) {
                headerPulse.canvas.width = headerPulse.canvas.offsetWidth;
                headerPulse.canvas.height = headerPulse.canvas.offsetHeight;
            }
        }

        // Handle window resize for all canvases
        window.addEventListener('resize', () => {
            resizeHeaderPulseCanvas(); // Resize header pulse
            for (const key in canvases) {
                if (canvases[key].canvas) {
                    resizeCanvas(canvases[key].canvas);
                }
            }
        });

        // --- Header "Stock Exchange Pulse" Animation ---
        function drawHeaderPulse() {
            const { canvas, ctx, data, maxDataPoints, valueRange, speed } = headerPulse;
            if (!ctx) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'rgba(10, 10, 13, 0.05)'; // Subtle trail
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Add new data point (random walk for stock-like feel)
            const lastValue = data.length > 0 ? data[data.length - 1] : valueRange / 2;
            let newValue = lastValue + (Math.random() - 0.5) * 10; // Fluctuation
            newValue = Math.max(5, Math.min(valueRange - 5, newValue)); // Keep within bounds
            data.push(newValue);

            // Keep only maxDataPoints
            if (data.length > maxDataPoints) {
                data.shift();
            }

            // Draw the pulse line
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(0, 227, 147, 0.9)'; // Lime green glow
            ctx.lineWidth = 1.5;
            ctx.shadowBlur = 8;
            ctx.shadowColor = 'rgba(0, 227, 147, 0.7)';

            const pointWidth = canvas.width / (maxDataPoints - 1);
            for (let i = 0; i < data.length; i++) {
                const x = i * pointWidth;
                const y = canvas.height - (data[i] / valueRange) * canvas.height; // Invert Y for graph
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();

            ctx.shadowBlur = 0; // Reset shadow

            headerPulse.animationId = requestAnimationFrame(drawHeaderPulse);
        }

        function startHeaderPulseAnimation() {
            // Initialize data with some random values
            for(let i = 0; i < headerPulse.maxDataPoints; i++) {
                headerPulse.data.push(Math.random() * headerPulse.valueRange);
            }
            drawHeaderPulse();
        }


        // --- Pulse Animation Classes & Functions (for Hero Grid) ---

        // Rhythmic Pulse (from fruitful.faa.zone/index.html, v5.0/v6.0)
        function drawRhythmicPulse(canvasObj) {
            const { canvas, ctx } = canvasObj;
            if (!ctx) return;

            /* Keep dark background for canvas animation */
            ctx.fillStyle = 'rgba(10, 10, 13, 0.15)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const numRhythmicLines = 40;
            const rhythmicLineAmplitude = canvas.height / 2.5;
            const rhythmicLineFrequency = 0.1;
            const rhythmicLineSpeed = 0.015;

            canvasObj.time += rhythmicLineSpeed;

            for (let i = 0; i < numRhythmicLines; i++) {
                ctx.beginPath();
                const offset = i * (Math.PI * 2 / numRhythmicLines);
                const colorHue = (canvasObj.time * 200 + i * 15) % 360;
                ctx.strokeStyle = `hsla(${colorHue}, 95%, 75%, 0.9)`;
                ctx.lineWidth = 2.5;

                for (let x = 0; x < canvas.width; x += 2) {
                    const y = Math.sin(x * rhythmicLineFrequency + canvasObj.time + offset) * (rhythmicLineAmplitude * (Math.sin(canvasObj.time * 0.3 + i * 0.15) * 0.5 + 0.5)) + canvas.height / 2;
                    if (x === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
            }
            canvasObj.animationId = requestAnimationFrame(() => drawRhythmicPulse(canvasObj));
        }

        // Concentric Waves (from v3.0)
        function drawConcentricWaves(canvasObj) {
            const { canvas, ctx } = canvasObj;
            if (!ctx) return;

            /* Keep dark background for canvas animation */
            ctx.fillStyle = 'rgba(10, 10, 13, 0.15)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const numWaves = 20;
            const waveSpeed = 0.02;
            const waveThickness = 4;
            const waveSpacing = 12;

            canvasObj.time += waveSpeed;

            for (let i = 0; i < numWaves; i++) {
                ctx.beginPath();
                const radius = (canvasObj.time * waveSpacing + i * waveSpacing) % (Math.max(canvas.width, canvas.height) / 1.2) + 5;
                const hue = (i * 20 + canvasObj.time * 100) % 360;
                ctx.strokeStyle = `hsla(${hue}, 95%, 80%, ${0.95 - (radius / (Math.max(canvas.width, canvas.height) / 1.2))})`;
                ctx.lineWidth = waveThickness;
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.stroke();

                if (i < 7) {
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius * 0.25, 0, Math.PI * 2);
                    ctx.fillStyle = `hsla(${hue + 70}, 100%, 85%, ${0.6 - (radius / (Math.max(canvas.width, canvas.height) / 1.2)) * 0.6})`;
                    ctx.fill();
                }
            }

            const coreRadius = 20 + Math.sin(canvasObj.time * 10) * 8;
            ctx.beginPath();
            ctx.arc(centerX, centerY, coreRadius, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(0, 227, 147, ${0.95 + Math.sin(canvasObj.time * 10) * 0.05})`;
            ctx.shadowBlur = 30;
            ctx.shadowColor = 'rgba(0, 227, 147, 1.0)';
            ctx.fill();
            ctx.shadowBlur = 0;

            canvasObj.animationId = requestAnimationFrame(() => drawConcentricWaves(canvasObj));
        }

        // Shooting Pulses (from v4.0/v6.0)
        class ShootingPulse {
            constructor(canvas) {
                this.canvas = canvas; // Store canvas reference
                this.x = Math.random() * this.canvas.width;
                this.y = Math.random() * this.canvas.height;
                this.initialRadius = 1;
                this.currentRadius = this.initialRadius;
                this.maxRadius = Math.random() * 150 + 80;
                this.speed = Math.random() * 4 + 2;
                this.alpha = 1;
                this.decayRate = Math.random() * 0.012 + 0.006;
                this.color = `hsl(${Math.random() * 360}, 100%, 80%)`;
                this.numRings = Math.floor(Math.random() * 6) + 5;
                this.glowStrength = Math.random() * 25 + 15;
            }
            update() {
                this.currentRadius += this.speed;
                this.alpha -= this.decayRate;
                return this.alpha > 0 && this.currentRadius < this.maxRadius;
            }
            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2.5;
                for (let i = 0; i < this.numRings; i++) {
                    const ringRadius = this.currentRadius - (i * (this.currentRadius / this.numRings));
                    if (ringRadius > this.initialRadius) {
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, ringRadius, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.initialRadius * 3, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.shadowBlur = this.glowStrength;
                ctx.shadowColor = this.color;
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.restore();
            }
        }

        function drawShootingPulses(canvasObj) {
            const { canvas, ctx, pulses } = canvasObj;
            if (!ctx) return;

            /* Keep dark background for canvas animation */
            ctx.fillStyle = 'rgba(10, 10, 13, 0.15)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const shootingPulseSpawnRate = 0.3;
            const maxShootingPulses = 50;

            if (Math.random() < shootingPulseSpawnRate && pulses.length < maxShootingPulses) {
                pulses.push(new ShootingPulse(canvas));
            }

            for (let i = pulses.length - 1; i >= 0; i--) {
                const pulse = pulses[i];
                if (pulse.update()) {
                    pulse.draw(ctx);
                } else {
                    pulses.splice(i, 1);
                }
            }
            canvasObj.animationId = requestAnimationFrame(() => drawShootingPulses(canvasObj));
        }

        // Particle Grid (from v2.0)
        class Particle {
            constructor(canvas) {
                this.canvas = canvas; // Store canvas reference
                this.x = Math.random() * this.canvas.width;
                this.y = Math.random() * this.canvas.height;
                this.size = Math.random() * 2.5 + 1.5;
                this.speedX = (Math.random() * 2 - 1);
                this.speedY = (Math.random() * 2 - 1);
                this.color = `hsl(${Math.random() * 360}, 100%, 80%)`;
                this.alpha = 1;
                this.decay = 0.002;
            }
            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.alpha -= this.decay;
                // Check bounds using this.canvas
                if (this.alpha < 0 || this.x < -20 || this.x > this.canvas.width + 20 || this.y < -20 || this.y > this.canvas.height + 20) {
                    this.alpha = 1;
                    this.x = Math.random() * this.canvas.width;
                    this.y = Math.random() * this.canvas.height;
                    this.speedX = (Math.random() * 2 - 1);
                    this.speedY = (Math.random() * 2 - 1);
                }
            }
            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.alpha;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawParticlesWithConnections(canvasObj) {
            const { canvas, ctx, particles } = canvasObj;
            if (!ctx) return;

            /* Keep dark background for canvas animation */
            ctx.fillStyle = 'rgba(10, 10, 13, 0.15)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (particles.length === 0) {
                for (let i = 0; i < 150; i++) {
                    particles.push(new Particle(canvas));
                }
            }

            for (let i = 0; i < particles.length; i++) {
                particles[i].update();
                particles[i].draw(ctx);

                for (let j = i; j < particles.length; j++) {
                    const dx = particles[i].x - particles[j].x;
                    const dy = particles[i].y - particles[j].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < 120) {
                        ctx.beginPath();
                        ctx.strokeStyle = `rgba(0, 123, 255, ${particles[i].alpha * particles[j].alpha * (1 - (distance / 120)) * 1.0})`;
                        ctx.lineWidth = 0.8;
                        ctx.moveTo(particles[i].x, particles[i].y);
                        ctx.lineTo(particles[j].x, particles[j].y);
                        ctx.stroke();
                    }
                }
            }
            ctx.globalAlpha = 1;
            canvasObj.animationId = requestAnimationFrame(() => drawParticlesWithConnections(canvasObj));
        }

        // Radial Bursts (New)
        class RadialBurst {
            constructor(canvas) {
                this.canvas = canvas; // Store canvas reference
                this.x = Math.random() * this.canvas.width;
                this.y = Math.random() * this.canvas.height;
                this.radius = 0;
                this.maxRadius = Math.random() * 200 + 100;
                this.speed = Math.random() * 5 + 3;
                this.alpha = 1;
                this.decay = Math.random() * 0.01 + 0.005;
                this.numLines = Math.floor(Math.random() * 20) + 15;
                this.color = `hsl(${Math.random() * 360}, 100%, 80%)`;
            }

            update() {
                this.radius += this.speed;
                this.alpha -= this.decay;
                return this.alpha > 0;
            }

            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;

                for (let i = 0; i < this.numLines; i++) {
                    const angle = (Math.PI * 2 / this.numLines) * i;
                    const startX = this.x + Math.cos(angle) * this.radius * 0.1;
                    const startY = this.y + Math.sin(angle) * this.radius * 0.1;
                    const endX = this.x + Math.cos(angle) * this.radius;
                    const endY = this.y + Math.sin(angle) * this.radius;

                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                }
                ctx.restore();
            }
        }

        function drawRadialBursts(canvasObj) {
            const { canvas, ctx, bursts } = canvasObj;
            if (!ctx) return;

            /* Keep dark background for canvas animation */
            ctx.fillStyle = 'rgba(10, 10, 13, 0.15)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const burstSpawnRate = 0.12;
            const maxBursts = 20;

            if (Math.random() < burstSpawnRate && bursts.length < maxBursts) {
                bursts.push(new RadialBurst(canvas));
            }

            for (let i = bursts.length - 1; i >= 0; i--) {
                const burst = bursts[i];
                if (burst.update()) {
                    burst.draw(ctx);
                } else {
                    bursts.splice(i, 1);
                }
            }
            canvasObj.animationId = requestAnimationFrame(() => drawRadialBursts(canvasObj));
        }

        // Hyperspace Warp (New)
        function drawHyperspaceWarp(canvasObj) {
            const { canvas, ctx } = canvasObj;
            if (!ctx) return;

            /* Keep dark background for canvas animation */
            ctx.fillStyle = 'rgba(10, 10, 13, 0.18)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            canvasObj.time += 0.06;

            const gridSpacing = 25;
            const lineCountX = Math.ceil(canvas.width / gridSpacing);
            const lineCountY = Math.ceil(canvas.height / gridSpacing);

            /* For B&W theme, use grey tones instead of vibrant color shifts for grid lines */
            ctx.strokeStyle = `rgba(100, 100, 100, ${0.7 + (Math.sin(canvasObj.time * 0.8) + 1) / 2 * 0.3})`;
            ctx.lineWidth = 1.5;

            // Draw horizontal lines
            for (let i = 0; i <= lineCountY; i++) {
                const y = i * gridSpacing;
                ctx.beginPath();
                ctx.moveTo(0, y + Math.sin(canvasObj.time + y * 0.03) * 20);
                ctx.lineTo(canvas.width, y + Math.sin(canvasObj.time + y * 0.03) * 20);
                ctx.stroke();
            }

            // Draw vertical lines
            for (let i = 0; i <= lineCountX; i++) {
                const x = i * gridSpacing;
                ctx.beginPath();
                ctx.moveTo(x + Math.cos(canvasObj.time + x * 0.03) * 20, 0);
                ctx.lineTo(x + Math.cos(canvasObj.time + x * 0.03) * 20, canvas.height);
                ctx.stroke();
            }
            canvasObj.animationId = requestAnimationFrame(() => drawHyperspaceWarp(canvasObj));
        }


        // Function to start the animation for a specific canvas (hero grid)
        function startAnimation(key) {
            const canvasObj = canvases[key];
            if (!canvasObj.ctx) return;

            // Cancel any existing animation frame to prevent duplicates
            if (canvasObj.animationId) {
                cancelAnimationFrame(canvasObj.animationId);
            }

            // Call the appropriate draw function for the canvas
            switch (key) {
                case 'rhythmic':
                    drawRhythmicPulse(canvasObj);
                    break;
                case 'concentric':
                    drawConcentricWaves(canvasObj);
                    break;
                case 'shooting':
                    drawShootingPulses(canvasObj);
                    break;
                case 'particles':
                    if (canvasObj.particles.length === 0) { // Initialize particles only once
                        for (let i = 0; i < 150; i++) { // Initial count increased to match draw logic
                            canvasObj.particles.push(new Particle(canvasObj.canvas));
                        }
                    }
                    drawParticlesWithConnections(canvasObj);
                    break;
                case 'radialBursts':
                    drawRadialBursts(canvasObj);
                    break;
                case 'hyperspace':
                    drawHyperspaceWarp(canvasObj);
                    break;
            }
        }

        // Chart.js for Node Pulse Graph
        let nodePulseChartInstance = null;
        function renderNodePulseChart() {
            const ctx = document.getElementById('nodePulseChart')?.getContext('2d');
            if (!ctx) return;

            if (nodePulseChartInstance) {
                nodePulseChartInstance.destroy(); // Destroy existing instance if any
            }

            const dataPoints = 50;
            const labels = Array.from({length: dataPoints}, (_, i) => `Tick ${i+1}`);
            // More dynamic data generation for better visual
            const coreNodeData = Array.from({length: dataPoints}, (v, i) => {
                const base = 50 + (i * 1.5);
                const fluctuation = (Math.random() - 0.5) * 40;
                return Math.floor(Math.max(0, base + fluctuation));
            });
            const arrayCountData = Array.from({length: dataPoints}, (v, i) => {
                const base = 100 + (i * 2);
                const fluctuation = (Math.random() - 0.5) * 60;
                return Math.floor(Math.max(0, base + fluctuation));
            });
            const repoInfiltrationData = Array.from({length: dataPoints}, (v, i) => {
                const base = 10 + (i * 0.8);
                const fluctuation = (Math.random() - 0.5) * 20;
                return Math.floor(Math.max(0, base + fluctuation));
            });

            nodePulseChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Core Nodes (Thousands)',
                            borderColor: 'rgba(0, 113, 227, 0.9)', /* Fruitful Blue for light mode */
                            backgroundColor: 'rgba(0, 113, 227, 0.1)',
                            fill: true,
                            tension: 0.4,
                            pointRadius: 0, // No points for a smooth pulse
                            borderWidth: 2
                        },
                        {
                            label: 'Array Counts (Hundreds)',
                            data: arrayCountData,
                            borderColor: 'rgba(48, 209, 88, 0.9)', /* Fruitful Green for light mode */
                            backgroundColor: 'rgba(48, 209, 88, 0.1)',
                            fill: true,
                            tension: 0.4,
                            pointRadius: 0,
                            borderWidth: 2
                        },
                        {
                            label: 'Repo Infiltrations',
                            data: repoInfiltrationData,
                            borderColor: 'rgba(255, 77, 77, 0.9)', /* Accent Red for light mode */
                            backgroundColor: 'rgba(255, 77, 77, 0.1)',
                            fill: true,
                            tension: 0.4,
                            pointRadius: 0,
                            borderWidth: 2
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        duration: 0 // Disable Chart.js default animation for continuous update
                    },
                    scales: {
                        x: {
                            display: false // Hide X-axis labels
                        },
                        y: {
                            beginAtZero: true,
                            ticks: {
                                color: 'var(--page-text-dark)' // Dark ticks for light background
                            },
                            grid: {
                                color: 'var(--page-border-light)' // Subtle grid lines
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            labels: {
                                color: 'var(--page-text-dark)' // Dark legend labels
                            }
                        }
                    }
                }
            });

            // Update chart data periodically to simulate live pulse
            setInterval(() => {
                const lastCore = nodePulseChartInstance.data.datasets[0].data[nodePulseChartInstance.data.datasets[0].data.length - 1];
                const lastArray = nodePulseChartInstance.data.datasets[1].data[nodePulseChartInstance.data.datasets[1].data.length - 1];
                const lastRepo = nodePulseChartInstance.data.datasets[2].data[nodePulseChartInstance.data.datasets[2].data.length - 1];

                const newDataPointCore = Math.floor(Math.max(0, lastCore + (Math.random() - 0.5) * 20)); // More dynamic change
                const newDataPointArray = Math.floor(Math.max(0, lastArray + (Math.random() - 0.5) * 30));
                const newDataPointRepo = Math.floor(Math.max(0, lastRepo + (Math.random() - 0.5) * 10));


                nodePulseChartInstance.data.labels.push(`Tick ${nodePulseChartInstance.data.labels.length + 1}`);
                nodePulseChartInstance.data.datasets[0].data.push(newDataPointCore);
                nodePulseChartInstance.data.datasets[1].data.push(newDataPointArray);
                nodePulseChartInstance.data.datasets[2].data.push(newDataPointRepo);

                // Remove old data points to maintain maxDataPoints
                if (nodePulseChartInstance.data.labels.length > dataPoints) {
                    nodePulseChartInstance.data.labels.shift();
                    nodePulseChartInstance.data.datasets[0].data.shift();
                    nodePulseChartInstance.data.datasets[1].data.shift();
                    nodePulseChartInstance.data.datasets[2].data.shift();
                }

                nodePulseChartInstance.update();
            }, 1000); // Update every 1 second
        }


        // Initialize all canvases and start their animations on window load
        window.onload = function() {
            initCanvases();
            renderNodePulseChart(); // Render the new Chart.js graph

            // Smooth scrolling for navigation links (if any were present)
            document.querySelectorAll('a[href^="#"]').forEach(anchor => {
                anchor.addEventListener('click', function (e) {
                    e.preventDefault();
                    document.querySelector(this.getAttribute('href')).scrollIntoView({
                        behavior: 'smooth'
                    });
                });
            });
        };
    </script>
</body>
</html>
